#!/usr/bin/env ruby
require 'optparse'

require File.join(File.dirname(__FILE__), '../lib/anygit')

module Anygit
  class IndexPackfile
    TMPDIR_BASE = File.join(File.dirname(__FILE__), '../tmp')

    def initialize(repo, path)
      @repo = repo
      @path = path

      @create ||= {}
      @tmpdir = File.join(TMPDIR_BASE, "#{repo.id}-#{Time.now.to_i}-#{rand}")

      Anygit.log.info("Storing mysql outfiles in #{@tmpdir}")
      Dir.mkdir(@tmpdir)
    end

    def run
      build_dumps
      close_files
      load_dumps
    end

    def build_dumps
      start = Time.now

      Rugged::Index.iterate_packfile(@path) do |processed, total, type, sha1, data|
        if processed % 100 == 0
          if (elapsed = Time.now - start) > 0.1
            rps = processed / elapsed
            remaining = (total - processed) / rps
            percent = (100.0 * processed) / total
            Anygit.log.info("Processed #{processed} / #{total} objects (#{percent.to_i}%) in #{format_time(elapsed)}. That's #{rps} records per second, so there should be about #{format_time(remaining)} remaining")
          end
        end

        store_object(type, sha1)

        # TODO: have iterate_packfile pass through git objects, and/or
        # add a parsing interface to Rugged.
        case type
        when :commit: index_commit(sha1, data)
        when :tree: index_tree(sha1, data)
        when :tag: index_tag(sha1, data)
        when :blob: index_blob(sha1)
        else
          raise "Invalid type: #{type.inspect}"
        end
      end
    end

    def close_files
      @create.each do |table, spec|
        path = spec[:file].path
        Anygit.log.info("Closing file for #{table} (#{path})")
        spec[:file].close
      end
    end

    def load_dumps
      @create.each do |table, spec|
        path = spec[:file].path
        Anygit.log.info("Loading #{table} (#{path})")
        # TODO: use better subprocess interface
        `mysql < #{path}`
      end
    end

    private

    def store_object(type, sha1)
      wrap_duplicates do
        create(Model::GitObject,
          :type => type,
          :sha1 => Util.sha1_to_bytes(sha1)
          )
      end

      wrap_duplicates do
        create(Model::ObjectRepo,
          :sha1 => Util.sha1_to_bytes(sha1),
          :repo_id => @repo.id
          )
      end
    end

    def wrap_duplicates(&blk)
      begin
        blk.call
      rescue DataObjects::IntegrityError => e
        Anygit.log.debug("Attempt to make duplicate object: #{e.message}")
      end
    end

    # "tree 460a692e68fa98c70e92380489e547bb0ce3f499\nparent e5a9524f345692f48292ef4d1f242060;95;c97e07c193\nparent ada7ba3a1964b790eb478332dc43d6046f49dcda\nauthor Vicent Mart\303\255 <tanoku@gmail.com> 1331485158 -0700\ncommitter Vicent Mart\303\255 <tanoku@gmail.com> 1331485158 -0700\n\nMerge pull request #45 from yandy/patch-2\n\ninspect method is called recursively"
    def index_commit(sha1, data)
      tree, parents = parse_commit(data)
      Anygit.log.debug("Commit #{sha1} has tree: #{tree.inspect}, parents: #{parents.inspect}")
      store_pointer_records(sha1, [tree] + parents)
    end

    # "100644 .gitignore\000\256k\344\257\264\016\377\201{\252\352\e46d~\rE\037\021100644 API\000YZ7\341\327\360\306B\363\201K\247\204\004Fy\301\377\324\303100644 Gemfile\000#\016\027\372\210\276\177&@\005\347\217<0\310\320\212\000S\024100644 Gemfile.lock\000\345CA4d\356:=\257\351\334\f#\262\323\374G\254\220|100644 LICENSE\000\3600\022\234\034kb\000\354=\217\213{fq\fYpo\361100644 README.md\000\030\354y(Z&\352b\001::&\336\030t\252\276O\243#100644 Rakefile\000\314\264\221\rh\305P\bL\251\377v:=*\270G)V[100644 TODO.txt\000\232c\220\177WV\226*\005\003m{T\ve\240u\3078\026100644 USAGE.rb\000\331\e;\233\020\315yw;B\361\235\276c\272\312m{` 40000 ext\000L\362\205d\263\001\016Q\252\221\323\f8\230K\213_\207\363\21040000 lib\000\243\351\006RE\367\3464\201h%5\355l\263W\030\254\000\346100644 rugged.gemspec\000\235\210v`&\027\302u\rw\303\335\224\031\200\310\206\204\374L40000 test\000*\253\206\b\326\320\375\351\231W\306\0028/\364\334\233S\341\340"
    def index_tree(sha1, data)
      children = parse_tree(data)
      Anygit.log.debug("Tree #{sha1} has children: #{children.inspect}")
      store_pointer_records(sha1, children)
    end

    # "object ec55c6ed695841b7453633f0c81187f0c4a11069\ntype commit\ntag v0.1.0\ntagger Scott Chacon <schacon@gmail.com> 1290556375 -0800\n\ninitial tag for version 0.1.0\n"
    def index_tag(sha1, data)
      object, type = parse_tag(data)
      Anygit.log.debug("Tag #{sha1} has object: #{object} (#{type})")
      store_pointer_records(sha1, [object])
    end

    def index_blob(sha1)
      Anygit.log.debug("Blob #{sha1} found")
    end

    def store_pointer_records(source, targets)
      targets.each do |target|
        wrap_duplicates do
          create(Model::ObjectPointer,
            :source => Util.sha1_to_bytes(source),
            :target => Util.sha1_to_bytes(target)
            )
        end
      end
    end

    def parse_commit(data)
      tree = nil
      parents = []

      iterlines(data) do |key, value|
        case key
        when 'tree': tree = value
        when 'parent': parents << value
        else
          raise "Unrecognized key: #{key.inspect} (value: #{value.inspect})" unless ['author', 'committer', 'mergetag', 'encoding'].include?(key)
        end
      end

      [tree, parents]
    end

    def parse_tree(data)
      data.scan(/(.*?)\0(.{20})/m).map do |name, sha1|
        raise "Invalid parse: #{name.inspect}" unless name =~ /^\d+ /
        Util.sha1_to_hex(sha1)
      end
    end

    def parse_tag(data)
      object = nil
      type = nil

      iterlines(data) do |key, value|
        case key
        when 'object': object = value
        when 'type': type = value
        else
          raise "Unrecognized key: #{key.inspect} (value: #{value.inspect})" unless ['tag', 'tagger'].include?(key)
        end
      end

      [object, type]
    end

    def iterlines(data, &blk)
      # Quick and dirty. Could probably do this without the stupid
      # regexes. This doesn't completely work (see
      # e22057c8599373e5caef0bc42bdb95d2a361ab0d in linux-2.6.git, which has
      #
      # mergetag object df7a3ee29b775edd1c2d75cf0b128b174bd4091e
      #  type commit
      #
      # but it's good enough.
      unless data =~ /\A(.*?)\n\n/m
        raise "Unrecognized data payload: #{data.inspect}"
      end

      $1.split("\n").each do |line|
        unless line =~ /^([^ ]*?) (.*)$/
          raise "Unrecognized data payload line: #{line.inspect}"
        end

        next if $1 == ''

        blk.call($1, $2)
      end
    end

    def format_time(a)
      a = a.to_i

      case a
      when 0 then 'no time'
      when 1 then 'a second'
      when 2..59 then a.to_s+' seconds'
      when 60..119 then 'a minute' #120 = 2 minutes
      when 120..3540 then (a/60).to_i.to_s+ ' minutes'
      when 3541..7100 then 'an hour' # 3600 = 1 hour
      when 7101..82800 then ((a+99)/3600).to_i.to_s+ ' hours'
      when 82801..172000 then 'tomorrow' # 86400 = 1 day
      when 172001..518400 then ((a+800)/(60*60*24)).to_i.to_s+ ' days'
      when 518400..1036800 then 'a week'
      else return (a/518400).to_s + ' weeks'
      end
    end

    def create(klass, data)
      table = Util.validate_table_name(klass.storage_name)
      keys = data.keys.sort_by {|k| k.to_s}
      unless @create.include?(table)
        f = File.open(File.join(@tmpdir, table + '.sql'), 'w')
        f.write("INSERT IGNORE INTO #{table} (#{keys.map {|k| Util.sql_column_name_quote(k) }.join(', ')}) VALUES")
        @create[table] = {:file => f, :keys => keys, :count => 0}
      end

      spec = @create[table]
      raise "Inconsistent keys: data has keys #{keys.inspect}, while table has keys #{spec[:keys].inspect}" unless spec[:keys] == keys

      if spec[:count] > 0
        spec[:file].write(',')
      end
      spec[:count] += 1

      spec[:file].write("(#{keys.map {|k| Util.sql_value_quote(data[k])}.join(', ')})")
    end
  end
end

def main
  options = {}
  optparse = OptionParser.new do |opts|
    opts.banner = "Usage: #{$0} [options] <url> <path>"

    opts.on('-h', '--help', 'Display this message') do
      puts opts
      exit(1)
    end

    opts.on('-c', '--create-repo', 'Create repo by url if it does not exist') do
      options[:create_repo] = true
    end
  end
  optparse.parse!

  if ARGV.length != 2
    puts optparse
    return 1
  end

  url = ARGV[0]
  path = File.expand_path(ARGV[1])

  Anygit::Model.init

  if options[:create_repo]
    repo = Anygit::Model::Repo.first_or_create(:url => url)
  else
    repo = Anygit::Model::Repo.get!(:url => url)
  end

  runner = Anygit::IndexPackfile.new(repo, path)
  runner.run
  return 0
end

if $0 == __FILE__
  ret = main
  begin
    exit(ret)
  rescue TypeError
    exit(0)
  end
end
